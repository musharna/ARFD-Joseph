---
title: "ARFD_RNAseq_Analysis"
output: html_document
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## Load Required Libraries

```{r libraries}
# Install packages if needed (uncomment as needed)
# BiocManager::install(c("DESeq2", "org.At.tair.db", "clusterProfiler", "GOSemSim"))
# install.packages(c("dplyr", "ggplot2", "pheatmap", "svglite", "ggrepel", "tidyr", "UpSetR", "eulerr"))

library(dplyr)
library(pheatmap)
library(ggplot2)
library(svglite)
library(DESeq2)
library(tidyr)
```

## Configuration - EDIT THIS SECTION

```{r configuration}
# =============================================================================
# CONFIGURATION - Modify these settings for your data
# =============================================================================

# Path to your featureCounts output file
counts_file <- "gene_counts.txt"

# Sample metadata - maps sample numbers to construct names
# Format: sample_number, construct_name, replicate
sample_metadata <- data.frame(
  sample_num = sprintf("%02d", 1:28),
  construct = c(
    "GUS", "GUS_aux", "5D", "6D", "7D", "8D", "19D",      # Replicate 1
    "GUS", "GUS_aux", "5D", "6D", "7D", "8D", "19D",      # Replicate 2
    "GUS", "GUS_aux", "5D", "6D", "7D", "8D", "19D",      # Replicate 3
    "GUS", "GUS_aux", "5D", "6D", "7D", "8D", "19D"       # Replicate 4
  ),
  replicate = c(
    rep(1, 7), rep(2, 7), rep(3, 7), rep(4, 7)
  ),
  stringsAsFactors = FALSE
)

# Create sample names in format "Construct-Replicate" (e.g., "GUS-1", "5D-2")
sample_metadata$sample_name <- paste0(sample_metadata$construct, "-", sample_metadata$replicate)

# Define control construct (for differential expression comparisons)
control_construct <- "GUS"

# All constructs in order (control first, then treatments)
all_constructs <- c("GUS", "GUS_aux", "5D", "6D", "7D", "8D", "19D")

# Constructs to compare against control (excluding the control itself)
treatment_constructs <- c("GUS_aux", "5D", "6D", "7D", "8D", "19D")

# DEG thresholds
padj_threshold <- 0.01      # Adjusted p-value cutoff
lfc_threshold <- 2          # Log2 fold change cutoff (absolute value)
min_avg_reads <- 20         # Minimum average normalized reads filter

# Number of samples to use (samples 1-28 based on your input)
n_samples <- 28
```

## Data Import and Preprocessing

```{r import_data}
# Read featureCounts output (skip the first comment line)
raw_counts <- read.table(counts_file, header = TRUE, sep = "\t",
                         skip = 1, check.names = FALSE, stringsAsFactors = FALSE)

# Extract gene annotation columns
gene_info <- raw_counts[, c("Geneid", "Chr", "Start", "End", "Strand", "Length")]

# Extract count columns (columns 7 onwards are the sample counts)
# Get column names and select only the first n_samples
count_cols <- colnames(raw_counts)[7:ncol(raw_counts)]

# Filter to only keep the samples we need (1-28)
keep_samples <- grep(paste0("24250R-01-(", paste(sprintf("%02d", 1:n_samples), collapse = "|"), ")_"),
                     count_cols, value = TRUE)

# Extract counts matrix
counts_matrix <- as.matrix(raw_counts[, keep_samples])
rownames(counts_matrix) <- raw_counts$Geneid

# Simplify column names to just sample numbers
colnames(counts_matrix) <- gsub(".*24250R-01-([0-9]+)_.*", "\\1", colnames(counts_matrix))

# Reorder columns to match sample_metadata order
counts_matrix <- counts_matrix[, sample_metadata$sample_num]

# Rename columns to descriptive sample names
colnames(counts_matrix) <- sample_metadata$sample_name

cat("Dimensions of counts matrix:", dim(counts_matrix), "\n")
cat("Sample names:", colnames(counts_matrix), "\n")
```

## Quality Control Plots

```{r qc_plots, fig.width=10, fig.height=6}
# Calculate library sizes
lib_sizes <- colSums(counts_matrix)

# Create a barplot of library sizes
lib_size_df <- data.frame(
  Sample = names(lib_sizes),
  Reads = lib_sizes,
  Construct = sample_metadata$construct
)

ggplot(lib_size_df, aes(x = Sample, y = Reads/1e6, fill = Construct)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Sample", y = "Million Reads", title = "Library Sizes")

# PCA on raw counts (after log transformation)
log_counts <- log2(counts_matrix + 1)
pca_result <- prcomp(t(log_counts), scale. = TRUE)

pca_df <- data.frame(
  PC1 = pca_result$x[,1],
  PC2 = pca_result$x[,2],
  Sample = rownames(pca_result$x),
  Construct = sample_metadata$construct
)

ggplot(pca_df, aes(x = PC1, y = PC2, color = Construct, label = Sample)) +
  geom_point(size = 3) +
  geom_text(vjust = -0.5, size = 3) +
  theme_bw() +
  labs(title = "PCA of Raw Counts (log2 transformed)")
```

## DESeq2 Normalization and Differential Expression

```{r deseq2_analysis}
# Create DESeq2 dataset
col_data <- data.frame(
  row.names = sample_metadata$sample_name,
  construct = factor(sample_metadata$construct, levels = all_constructs),
  replicate = factor(sample_metadata$replicate)
)

dds <- DESeqDataSetFromMatrix(
  countData = counts_matrix,
  colData = col_data,
  design = ~ construct
)

# Pre-filter low-count genes
keep <- rowSums(counts(dds) >= 10) >= 3
dds <- dds[keep, ]

# Run DESeq2
dds <- DESeq(dds)

# Get normalized counts
norm_counts <- counts(dds, normalized = TRUE)
```

## Compute Average Normalized Reads per Construct

```{r compute_averages}
# Create a data frame to hold all results
df <- data.frame(Geneid = rownames(norm_counts))

# Add normalized counts for each sample
for (i in 1:ncol(norm_counts)) {
  df[[colnames(norm_counts)[i]]] <- norm_counts[, i]
}

# Compute average normalized reads for each construct
for (con in all_constructs) {
  # Find all columns that match this construct
  cols <- grep(paste0("^", con, "-\\d+$"), names(df), value = TRUE)
  avg_col <- paste0("avg_reads-", con)
  df[[avg_col]] <- rowMeans(df[, cols, drop = FALSE], na.rm = TRUE)
}

# Save normalized counts with averages
write.csv(df, file = "ARFD_normalized_counts_with_averages.csv", row.names = FALSE, quote = TRUE)

cat("Created average columns for constructs:", all_constructs, "\n")
```

## Differential Expression Analysis

```{r differential_expression}
# Extract DE results for each treatment vs control
de_results_list <- list()

for (con in treatment_constructs) {
  # Get DESeq2 results
  res <- results(dds, contrast = c("construct", con, control_construct))
  res_df <- as.data.frame(res)
  res_df$Geneid <- rownames(res_df)

  # Rename columns to include construct name
  colnames(res_df)[colnames(res_df) == "log2FoldChange"] <- paste0("log2FoldChange-", con)
  colnames(res_df)[colnames(res_df) == "pvalue"] <- paste0("pvalue-", con)
  colnames(res_df)[colnames(res_df) == "padj"] <- paste0("padj-", con)
  colnames(res_df)[colnames(res_df) == "baseMean"] <- paste0("baseMean-", con)
  colnames(res_df)[colnames(res_df) == "lfcSE"] <- paste0("lfcSE-", con)
  colnames(res_df)[colnames(res_df) == "stat"] <- paste0("stat-", con)

  de_results_list[[con]] <- res_df
}

# Merge all DE results with the normalized counts
df2 <- df
for (con in treatment_constructs) {
  res_df <- de_results_list[[con]]
  cols_to_add <- setdiff(colnames(res_df), "Geneid")
  df2 <- merge(df2, res_df[, c("Geneid", cols_to_add)], by = "Geneid", all.x = TRUE)
}
```

## Classify Up/Down Regulated Genes

```{r classify_updown}
# Define control average reads column
control_col <- paste0("avg_reads-", control_construct)

# Loop over treatment constructs to classify Up/Down
for (con in treatment_constructs) {
  l2fc_col <- paste0("log2FoldChange-", con)
  padj_col <- paste0("padj-", con)
  avg_col <- paste0("avg_reads-", con)
  up_down_col <- paste0("Up_Down-", con)

  # Classify based on thresholds:
  # - padj < threshold
  # - |log2FoldChange| > lfc_threshold
  # - average reads for treatment OR control > min_avg_reads
  df2[[up_down_col]] <- ifelse(
    !is.na(df2[[padj_col]]) &
      df2[[padj_col]] < padj_threshold &
      abs(df2[[l2fc_col]]) > lfc_threshold &
      (df2[[avg_col]] > min_avg_reads | df2[[control_col]] > min_avg_reads),
    ifelse(df2[[l2fc_col]] > 0, "UP", "Down"),
    ""
  )
}

# Save results
write.csv(df2, file = paste0("ARFD_DE_results_LFC", lfc_threshold, "_p",
                              gsub("\\.", "", as.character(padj_threshold)), ".csv"),
          row.names = FALSE, quote = TRUE)

# Print summary
cat("\n=== Differential Expression Summary ===\n")
for (con in treatment_constructs) {
  up_down_col <- paste0("Up_Down-", con)
  n_up <- sum(df2[[up_down_col]] == "UP", na.rm = TRUE)
  n_down <- sum(df2[[up_down_col]] == "Down", na.rm = TRUE)
  cat(sprintf("%s: %d UP, %d Down\n", con, n_up, n_down))
}
```

## Generate Heatmaps

### All DEGs Heatmap

```{r heatmap_all_degs, fig.width=10, fig.height=8}
# Define Up/Down columns
ud_cols <- paste0("Up_Down-", treatment_constructs)

# Filter for any gene that is UP or Down in at least one construct
df_DEGs <- df2 %>%
  filter(if_any(all_of(ud_cols), ~ . %in% c("UP", "Down")))

cat("Total DEGs across all constructs:", nrow(df_DEGs), "\n")

# Define constructs for heatmap (include control)
constructs_for_heatmap <- all_constructs
counts_cols <- paste0("avg_reads-", constructs_for_heatmap)

# Create heatmap matrix
df_heat <- df_DEGs %>%
  dplyr::select(all_of(counts_cols)) %>%
  as.matrix()
rownames(df_heat) <- df_DEGs$Geneid

# Remove rows with all zeros or NAs
df_heat <- df_heat[rowSums(df_heat, na.rm = TRUE) > 0, ]
df_heat <- df_heat[complete.cases(df_heat), ]

if (nrow(df_heat) > 0) {
  # Elbow method for k-means clustering
  WSS <- numeric(14)
  for (k in 2:15) {
    set.seed(123)
    km <- kmeans(df_heat, centers = k, nstart = 25, iter.max = 30)
    WSS[k - 1] <- km$tot.withinss
  }

  svglite("K-means_all_DEGs.svg", width = 10, height = 7)
  plot(2:15, WSS,
       type = "b",
       xlab = "# of Clusters (K)",
       ylab = "Total within-clusters sum of squares",
       main = "Elbow Method for k-means")
  dev.off()

  # Create heatmap
  svglite("All_DEGs_heatmap.svg", width = 10, height = 8)
  heat_all <- pheatmap(
    df_heat,
    scale = "row",
    show_rownames = FALSE,
    show_colnames = TRUE,
    cluster_cols = FALSE,
    cluster_rows = TRUE,
    cutree_rows = 9,
    main = "All DEGs Heatmap"
  )
  dev.off()

  # Display heatmap in notebook
  pheatmap(
    df_heat,
    scale = "row",
    show_rownames = FALSE,
    show_colnames = TRUE,
    cluster_cols = FALSE,
    cluster_rows = TRUE,
    cutree_rows = 9,
    main = "All DEGs Heatmap"
  )
}
```

### Extract Gene Clusters

```{r extract_clusters}
if (exists("heat_all") && !is.null(heat_all$tree_row)) {
  # Get cluster assignments
  clusters <- cutree(heat_all$tree_row, k = 9)
  annotation_df <- data.frame(Cluster = factor(clusters))
  rownames(annotation_df) <- names(clusters)

  # Create heatmap with cluster annotation
  svglite("All_DEGs_heatmap_clustered.svg", width = 10, height = 8)
  pheatmap(
    df_heat,
    scale = "row",
    show_rownames = FALSE,
    show_colnames = TRUE,
    cluster_cols = FALSE,
    cluster_rows = TRUE,
    cutree_rows = 9,
    annotation_row = annotation_df,
    main = "All DEGs with Cluster Annotations"
  )
  dev.off()

  # Save cluster assignments
  row_clust <- data.frame(
    GeneID = names(clusters),
    Cluster = clusters
  )
  write.csv(row_clust, file = "gene_clusters.csv", row.names = FALSE, quote = TRUE)

  # Merge cluster info back to main results
  df2 <- merge(df2, row_clust, by.x = "Geneid", by.y = "GeneID", all.x = TRUE)
  write.csv(df2, file = paste0("ARFD_DE_results_LFC", lfc_threshold, "_p",
                                gsub("\\.", "", as.character(padj_threshold)), "_clustered.csv"),
            row.names = FALSE, quote = TRUE)

  cat("\nGenes per cluster:\n")
  print(table(row_clust$Cluster))
}
```

### Auxin-Responsive Genes Heatmap (GUS_aux DEGs)

```{r heatmap_auxin_responsive, fig.width=10, fig.height=6}
# Filter for genes differentially expressed in GUS_aux vs GUS
df_auxin_responsive <- df2 %>%
  filter(`Up_Down-GUS_aux` %in% c("UP", "Down"))

if (nrow(df_auxin_responsive) > 0) {
  cat("Auxin-responsive genes (GUS_aux DEGs):", nrow(df_auxin_responsive), "\n")

  df_heat_aux <- df_auxin_responsive %>%
    dplyr::select(all_of(counts_cols)) %>%
    as.matrix()
  rownames(df_heat_aux) <- df_auxin_responsive$Geneid

  svglite("Auxin_Responsive_heatmap.svg", width = 10, height = 6)
  pheatmap(
    df_heat_aux,
    scale = "row",
    show_rownames = FALSE,
    show_colnames = TRUE,
    cluster_cols = FALSE,
    cluster_rows = TRUE,
    main = "Auxin-Responsive Genes Heatmap"
  )
  dev.off()
}
```

## Volcano Plots

```{r volcano_plots, fig.width=10, fig.height=6}
library(ggrepel)

# Create volcano plot for each treatment
for (con in treatment_constructs) {
  l2fc_col <- paste0("log2FoldChange-", con)
  padj_col <- paste0("padj-", con)
  up_down_col <- paste0("Up_Down-", con)

  # Prepare plot data
  plot_data <- df2 %>%
    filter(!is.na(.data[[padj_col]]) & !is.na(.data[[l2fc_col]])) %>%
    mutate(
      neg_log10_padj = -log10(.data[[padj_col]]),
      regulation = ifelse(.data[[up_down_col]] == "UP", "Upregulated",
                          ifelse(.data[[up_down_col]] == "Down", "Downregulated", "Not significant"))
    )

  p <- ggplot(plot_data, aes_string(x = paste0("`", l2fc_col, "`"),
                                     y = "neg_log10_padj",
                                     col = "regulation")) +
    geom_vline(xintercept = c(-lfc_threshold, lfc_threshold), col = 'gray', linetype = 'dashed') +
    geom_hline(yintercept = -log10(padj_threshold), col = 'gray', linetype = 'dashed') +
    geom_point(size = 1, alpha = 0.7) +
    scale_color_manual(values = c('Downregulated' = '#639FC4',
                                  'Not significant' = 'gray',
                                  'Upregulated' = '#FFB300')) +
    labs(color = con,
         x = expression('log'[2]*'FC'),
         y = expression('-log'[10]*'adjusted p-value'),
         title = paste("Volcano Plot:", con, "vs", control_construct)) +
    theme_classic()

  print(p)

  svglite(paste0("Volcano_", con, ".svg"), width = 10, height = 6)
  print(p)
  dev.off()
}
```

## Expression Boxplots for Selected Genes

```{r boxplots_selected_genes, fig.width=12, fig.height=10}
# Define genes of interest (modify as needed)
# Example: top 10 most significantly DE genes across all constructs
genes_of_interest <- df2 %>%
  filter(if_any(all_of(ud_cols), ~ . %in% c("UP", "Down"))) %>%
  head(20) %>%
  pull(Geneid)

if (length(genes_of_interest) > 0) {
  # Get sample columns (excluding averages)
  sample_cols <- sample_metadata$sample_name

  # Reshape data for plotting
  df_long <- df2 %>%
    filter(Geneid %in% genes_of_interest) %>%
    dplyr::select(Geneid, all_of(sample_cols)) %>%
    pivot_longer(
      cols = all_of(sample_cols),
      names_to = "Sample",
      values_to = "Normalized_Reads"
    ) %>%
    mutate(
      Construct = gsub("-\\d+$", "", Sample),
      Construct = factor(Construct, levels = all_constructs)
    )

  ggplot(df_long, aes(x = Construct, y = Normalized_Reads)) +
    geom_boxplot() +
    facet_wrap(~ Geneid, scales = "free_y", ncol = 4) +
    theme_bw(base_size = 10) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(
      x = "Construct",
      y = "Normalized Reads",
      title = "Expression of Selected Genes Across Constructs"
    )
}
```

## UpSet Plots

```{r upset_plots, fig.width=10, fig.height=6}
library(UpSetR)

# Prepare gene sets for UP-regulated genes
up_genes_list <- list()
down_genes_list <- list()

for (con in treatment_constructs) {
  up_down_col <- paste0("Up_Down-", con)

  up_genes_list[[con]] <- df2 %>%
    filter(.data[[up_down_col]] == "UP") %>%
    pull(Geneid)

  down_genes_list[[con]] <- df2 %>%
    filter(.data[[up_down_col]] == "Down") %>%
    pull(Geneid)
}

# UP-regulated UpSet plot
if (any(sapply(up_genes_list, length) > 0)) {
  upset_matrix_up <- fromList(up_genes_list)

  svglite("UpSet_UP_regulated.svg", width = 10, height = 6)
  print(upset(
    upset_matrix_up,
    sets = treatment_constructs,
    keep.order = TRUE,
    order.by = "freq",
    mainbar.y.label = "UP-regulated gene intersections",
    sets.x.label = "Genes per construct"
  ))
  dev.off()

  upset(
    upset_matrix_up,
    sets = treatment_constructs,
    keep.order = TRUE,
    order.by = "freq",
    mainbar.y.label = "UP-regulated gene intersections",
    sets.x.label = "Genes per construct"
  )
}

# DOWN-regulated UpSet plot
if (any(sapply(down_genes_list, length) > 0)) {
  upset_matrix_down <- fromList(down_genes_list)

  svglite("UpSet_DOWN_regulated.svg", width = 10, height = 6)
  print(upset(
    upset_matrix_down,
    sets = treatment_constructs,
    keep.order = TRUE,
    order.by = "freq",
    mainbar.y.label = "DOWN-regulated gene intersections",
    sets.x.label = "Genes per construct"
  ))
  dev.off()

  upset(
    upset_matrix_down,
    sets = treatment_constructs,
    keep.order = TRUE,
    order.by = "freq",
    mainbar.y.label = "DOWN-regulated gene intersections",
    sets.x.label = "Genes per construct"
  )
}
```

## GO Term Enrichment Analysis

```{r go_enrichment, fig.width=12, fig.height=10}
library(clusterProfiler)
library(org.At.tair.db)

# Perform GO enrichment for each construct's UP-regulated genes
all_enrichment_results <- list()

for (con in treatment_constructs) {
  up_down_col <- paste0("Up_Down-", con)

  # Get UP-regulated genes
  up_genes <- df2 %>%
    filter(.data[[up_down_col]] == "UP") %>%
    pull(Geneid)

  if (length(up_genes) >= 5) {  # Need minimum genes for enrichment
    ego <- tryCatch({
      enrichGO(
        gene = up_genes,
        OrgDb = org.At.tair.db,
        keyType = "TAIR",
        ont = "BP",
        pAdjustMethod = "BH",
        pvalueCutoff = 0.05,
        qvalueCutoff = 0.05
      )
    }, error = function(e) {
      message(sprintf("No enrichment results for %s: %s", con, e$message))
      return(NULL)
    })

    if (!is.null(ego) && nrow(as.data.frame(ego)) > 0) {
      ego_df <- as.data.frame(ego) %>%
        arrange(p.adjust) %>%
        head(15)
      ego_df$Construct <- con
      all_enrichment_results[[con]] <- ego_df
    }
  }
}

# Combine and plot if results exist
if (length(all_enrichment_results) > 0) {
  combined_enrichment <- bind_rows(all_enrichment_results)
  combined_enrichment$Construct <- factor(combined_enrichment$Construct,
                                          levels = treatment_constructs)

  p_go <- ggplot(combined_enrichment, aes(
    x = Construct,
    y = Description,
    size = Count,
    color = -log10(p.adjust)
  )) +
    geom_point() +
    scale_color_gradientn(colours = c("#440F57", "#424285", "#2C748E", "#37B977", "#FFCB27")) +
    theme_bw() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      axis.text.y = element_text(size = 8)
    ) +
    labs(title = "GO Term Enrichment (UP-regulated genes)")

  print(p_go)

  ggsave("GO_enrichment_UP.svg", plot = p_go, width = 12, height = 10)
}
```

## Inverse Correlation Analysis

```{r inverse_correlation}
# Find genes inversely correlated with a reference gene
# Modify reference_gene as needed

reference_gene <- "AT1G15050"  # Example: modify to your gene of interest

# Get sample columns
sample_cols <- sample_metadata$sample_name

# Create expression matrix for DEGs
df_DEGs_expr <- df2 %>%
  filter(if_any(all_of(ud_cols), ~ . %in% c("UP", "Down"))) %>%
  dplyr::select(Geneid, all_of(sample_cols))

if (reference_gene %in% df_DEGs_expr$Geneid) {
  expr_mat <- df_DEGs_expr %>%
    column_to_rownames("Geneid") %>%
    as.matrix()

  ref_expr <- as.numeric(expr_mat[reference_gene, ])

  # Calculate correlations
  gene_cor <- apply(expr_mat, 1, function(x) {
    cor(x, ref_expr, use = "pairwise.complete.obs", method = "pearson")
  })

  # Calculate p-values
  p_vals <- apply(expr_mat, 1, function(x) {
    test_result <- cor.test(x, ref_expr, use = "pairwise.complete.obs", method = "pearson")
    test_result$p.value
  })

  # Adjust p-values
  p_adj <- p.adjust(p_vals, method = "BH")

  # Combine results
  cor_results <- data.frame(
    Geneid = rownames(expr_mat),
    correlation = gene_cor,
    p_value = p_vals,
    p_adj = p_adj
  )

  # Filter for inversely correlated genes
  inversely_correlated <- cor_results %>%
    filter(correlation < -0.5 & p_adj < 0.05)

  cat("\nGenes inversely correlated with", reference_gene, ":\n")
  cat("Number of inversely correlated genes:", nrow(inversely_correlated), "\n")

  if (nrow(inversely_correlated) > 0) {
    write.csv(inversely_correlated,
              file = paste0(reference_gene, "_inverse_correlations.csv"),
              row.names = FALSE, quote = TRUE)
  }
}
```

## Session Info

```{r session_info}
sessionInfo()
```
