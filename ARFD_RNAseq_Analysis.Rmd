---
title: "ARFD_RNAseq_Analysis"
output: html_document
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## Load Required Libraries

```{r libraries}
# Install packages if needed (uncomment as needed)
# BiocManager::install(c("DESeq2", "org.At.tair.db", "clusterProfiler", "GOSemSim"))
# install.packages(c("dplyr", "ggplot2", "pheatmap", "svglite", "ggrepel", "tidyr", "UpSetR", "eulerr"))

library(dplyr)
library(pheatmap)
library(ggplot2)
library(svglite)
library(DESeq2)
library(tidyr)
```

## Configuration - EDIT THIS SECTION

```{r configuration}
# =============================================================================
# CONFIGURATION - Modify these settings for your data
# =============================================================================

# Path to your featureCounts output file
counts_file <- "gene_counts.txt"

# Sample metadata - maps sample numbers to construct names
# Format: sample_number, construct_name, replicate
sample_metadata <- data.frame(
  sample_num = sprintf("%02d", 1:28),
  construct = c(
    "GUS", "GUS_aux", "5D", "6D", "7D", "8D", "19D",      # Replicate 1
    "GUS", "GUS_aux", "5D", "6D", "7D", "8D", "19D",      # Replicate 2
    "GUS", "GUS_aux", "5D", "6D", "7D", "8D", "19D",      # Replicate 3
    "GUS", "GUS_aux", "5D", "6D", "7D", "8D", "19D"       # Replicate 4
  ),
  replicate = c(
    rep(1, 7), rep(2, 7), rep(3, 7), rep(4, 7)
  ),
  stringsAsFactors = FALSE
)

# Create sample names in format "Construct-Replicate" (e.g., "GUS-1", "5D-2")
sample_metadata$sample_name <- paste0(sample_metadata$construct, "-", sample_metadata$replicate)

# Define control construct (for differential expression comparisons)
control_construct <- "GUS"

# All constructs in order (control first, then treatments)
all_constructs <- c("GUS", "GUS_aux", "5D", "6D", "7D", "8D", "19D")

# Constructs to compare against control (excluding the control itself)
treatment_constructs <- c("GUS_aux", "5D", "6D", "7D", "8D", "19D")

# DEG thresholds
padj_threshold <- 0.01      # Adjusted p-value cutoff
lfc_threshold <- 2          # Log2 fold change cutoff (absolute value)
min_avg_reads <- 20         # Minimum average normalized reads filter

# Number of samples to use (samples 1-28 based on your input)
n_samples <- 28
```

## Data Import and Preprocessing

```{r import_data}
# Read featureCounts output (skip the first comment line)
raw_counts <- read.table(counts_file, header = TRUE, sep = "\t",
                         skip = 1, check.names = FALSE, stringsAsFactors = FALSE)

# Extract gene annotation columns
gene_info <- raw_counts[, c("Geneid", "Chr", "Start", "End", "Strand", "Length")]

# Extract count columns (columns 7 onwards are the sample counts)
# Get column names and select only the first n_samples
count_cols <- colnames(raw_counts)[7:ncol(raw_counts)]

# Filter to only keep the samples we need (1-28)
keep_samples <- grep(paste0("24250R-01-(", paste(sprintf("%02d", 1:n_samples), collapse = "|"), ")_"),
                     count_cols, value = TRUE)

# Extract counts matrix
counts_matrix <- as.matrix(raw_counts[, keep_samples])
rownames(counts_matrix) <- raw_counts$Geneid

# Simplify column names to just sample numbers
colnames(counts_matrix) <- gsub(".*24250R-01-([0-9]+)_.*", "\\1", colnames(counts_matrix))

# Reorder columns to match sample_metadata order
counts_matrix <- counts_matrix[, sample_metadata$sample_num]

# Rename columns to descriptive sample names
colnames(counts_matrix) <- sample_metadata$sample_name

cat("Dimensions of counts matrix:", dim(counts_matrix), "\n")
cat("Sample names:", colnames(counts_matrix), "\n")
```

## Quality Control Plots

```{r qc_plots, fig.width=10, fig.height=6}
# Calculate library sizes
lib_sizes <- colSums(counts_matrix)

# Create a barplot of library sizes
lib_size_df <- data.frame(
  Sample = names(lib_sizes),
  Reads = lib_sizes,
  Construct = sample_metadata$construct
)

ggplot(lib_size_df, aes(x = Sample, y = Reads/1e6, fill = Construct)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Sample", y = "Million Reads", title = "Library Sizes")

# PCA on raw counts (after log transformation)
log_counts <- log2(counts_matrix + 1)

# Filter out genes with zero variance (constant expression) before PCA
gene_vars <- apply(log_counts, 1, var)
log_counts_filtered <- log_counts[gene_vars > 0, ]
cat("Genes removed due to zero variance:", sum(gene_vars == 0), "\n")
cat("Genes remaining for PCA:", nrow(log_counts_filtered), "\n")

pca_result <- prcomp(t(log_counts_filtered), scale. = TRUE)

pca_df <- data.frame(
  PC1 = pca_result$x[,1],
  PC2 = pca_result$x[,2],
  Sample = rownames(pca_result$x),
  Construct = sample_metadata$construct
)

# Calculate variance explained
var_explained <- round(100 * pca_result$sdev^2 / sum(pca_result$sdev^2), 1)

ggplot(pca_df, aes(x = PC1, y = PC2, color = Construct, label = Sample)) +
  geom_point(size = 3) +
  geom_text(vjust = -0.5, size = 3) +
  theme_bw() +
  labs(title = "PCA of Raw Counts (log2 transformed)",
       x = paste0("PC1 (", var_explained[1], "% variance)"),
       y = paste0("PC2 (", var_explained[2], "% variance)"))
```

## DESeq2 Normalization and Differential Expression

```{r deseq2_analysis}
# Create DESeq2 dataset
col_data <- data.frame(
  row.names = sample_metadata$sample_name,
  construct = factor(sample_metadata$construct, levels = all_constructs),
  replicate = factor(sample_metadata$replicate)
)

dds <- DESeqDataSetFromMatrix(
  countData = counts_matrix,
  colData = col_data,
  design = ~ construct
)

# Run DESeq2
dds <- DESeq(dds)

# Get normalized counts
norm_counts <- counts(dds, normalized = TRUE)
```

## Compute Average Normalized Reads per Construct

```{r compute_averages}
# Create a data frame to hold all results
df <- data.frame(Geneid = rownames(norm_counts))

# Add normalized counts for each sample
for (i in 1:ncol(norm_counts)) {
  df[[colnames(norm_counts)[i]]] <- norm_counts[, i]
}

# Compute average normalized reads for each construct
for (con in all_constructs) {
  # Find all columns that match this construct
  cols <- grep(paste0("^", con, "-\\d+$"), names(df), value = TRUE)
  avg_col <- paste0("avg_reads-", con)
  df[[avg_col]] <- rowMeans(df[, cols, drop = FALSE], na.rm = TRUE)
}

# Save normalized counts with averages
write.csv(df, file = "ARFD_normalized_counts_with_averages.csv", row.names = FALSE, quote = TRUE)

cat("Created average columns for constructs:", all_constructs, "\n")
```

## Differential Expression Analysis

```{r differential_expression}
# Extract DE results for each treatment vs control
de_results_list <- list()

for (con in treatment_constructs) {
  # Get DESeq2 results
  res <- results(dds, contrast = c("construct", con, control_construct))
  res_df <- as.data.frame(res)
  res_df$Geneid <- rownames(res_df)

  # Rename columns to include construct name
  colnames(res_df)[colnames(res_df) == "log2FoldChange"] <- paste0("log2FoldChange-", con)
  colnames(res_df)[colnames(res_df) == "pvalue"] <- paste0("pvalue-", con)
  colnames(res_df)[colnames(res_df) == "padj"] <- paste0("padj-", con)
  colnames(res_df)[colnames(res_df) == "baseMean"] <- paste0("baseMean-", con)
  colnames(res_df)[colnames(res_df) == "lfcSE"] <- paste0("lfcSE-", con)
  colnames(res_df)[colnames(res_df) == "stat"] <- paste0("stat-", con)

  de_results_list[[con]] <- res_df
}

# Merge all DE results with the normalized counts
df2 <- df
for (con in treatment_constructs) {
  res_df <- de_results_list[[con]]
  cols_to_add <- setdiff(colnames(res_df), "Geneid")
  df2 <- merge(df2, res_df[, c("Geneid", cols_to_add)], by = "Geneid", all.x = TRUE)
}
```

## Classify Up/Down Regulated Genes

```{r classify_updown}
# Define control average reads column
control_col <- paste0("avg_reads-", control_construct)

# Loop over treatment constructs to classify Up/Down
for (con in treatment_constructs) {
  l2fc_col <- paste0("log2FoldChange-", con)
  padj_col <- paste0("padj-", con)
  avg_col <- paste0("avg_reads-", con)
  up_down_col <- paste0("Up_Down-", con)

  # Classify based on thresholds:
  # - padj < threshold
  # - |log2FoldChange| > lfc_threshold
  # - average reads for treatment OR control > min_avg_reads
  df2[[up_down_col]] <- ifelse(
    !is.na(df2[[padj_col]]) &
      df2[[padj_col]] < padj_threshold &
      abs(df2[[l2fc_col]]) > lfc_threshold &
      (df2[[avg_col]] > min_avg_reads | df2[[control_col]] > min_avg_reads),
    ifelse(df2[[l2fc_col]] > 0, "UP", "Down"),
    ""
  )
}

# Save results
write.csv(df2, file = paste0("ARFD_DE_results_LFC", lfc_threshold, "_p",
                              gsub("\\.", "", as.character(padj_threshold)), ".csv"),
          row.names = FALSE, quote = TRUE)

# Print summary
cat("\n=== Differential Expression Summary ===\n")
for (con in treatment_constructs) {
  up_down_col <- paste0("Up_Down-", con)
  n_up <- sum(df2[[up_down_col]] == "UP", na.rm = TRUE)
  n_down <- sum(df2[[up_down_col]] == "Down", na.rm = TRUE)
  cat(sprintf("%s: %d UP, %d Down\n", con, n_up, n_down))
}
```

## Generate Heatmaps

### All DEGs Heatmap

```{r heatmap_all_degs, fig.width=10, fig.height=8}
# Define Up/Down columns
ud_cols <- paste0("Up_Down-", treatment_constructs)

# Filter for any gene that is UP or Down in at least one construct
df_DEGs <- df2 %>%
  filter(if_any(all_of(ud_cols), ~ . %in% c("UP", "Down")))

cat("Total DEGs across all constructs:", nrow(df_DEGs), "\n")

# Define constructs for heatmap (include control)
constructs_for_heatmap <- all_constructs
counts_cols <- paste0("avg_reads-", constructs_for_heatmap)

# Create heatmap matrix
df_heat <- df_DEGs %>%
  dplyr::select(all_of(counts_cols)) %>%
  as.matrix()
rownames(df_heat) <- df_DEGs$Geneid

# Remove rows with all zeros or NAs
df_heat <- df_heat[rowSums(df_heat, na.rm = TRUE) > 0, ]
df_heat <- df_heat[complete.cases(df_heat), ]

if (nrow(df_heat) > 0) {
  # Elbow method for k-means clustering
  WSS <- numeric(14)
  for (k in 2:15) {
    set.seed(123)
    km <- kmeans(df_heat, centers = k, nstart = 25, iter.max = 30)
    WSS[k - 1] <- km$tot.withinss
  }

  svglite("K-means_all_DEGs.svg", width = 10, height = 7)
  plot(2:15, WSS,
       type = "b",
       xlab = "# of Clusters (K)",
       ylab = "Total within-clusters sum of squares",
       main = "Elbow Method for k-means")
  dev.off()

  # Create heatmap
  svglite("All_DEGs_heatmap.svg", width = 10, height = 8)
  heat_all <- pheatmap(
    df_heat,
    scale = "row",
    show_rownames = FALSE,
    show_colnames = TRUE,
    cluster_cols = FALSE,
    cluster_rows = TRUE,
    cutree_rows = 9,
    main = "All DEGs Heatmap"
  )
  dev.off()

  # Display heatmap in notebook
  pheatmap(
    df_heat,
    scale = "row",
    show_rownames = FALSE,
    show_colnames = TRUE,
    cluster_cols = FALSE,
    cluster_rows = TRUE,
    cutree_rows = 9,
    main = "All DEGs Heatmap"
  )
}
```

### Extract Gene Clusters

```{r extract_clusters}
if (exists("heat_all") && !is.null(heat_all$tree_row)) {
  # Get cluster assignments
  clusters <- cutree(heat_all$tree_row, k = 9)
  annotation_df <- data.frame(Cluster = factor(clusters))
  rownames(annotation_df) <- names(clusters)

  # Create heatmap with cluster annotation
  svglite("All_DEGs_heatmap_clustered.svg", width = 10, height = 8)
  pheatmap(
    df_heat,
    scale = "row",
    show_rownames = FALSE,
    show_colnames = TRUE,
    cluster_cols = FALSE,
    cluster_rows = TRUE,
    cutree_rows = 9,
    annotation_row = annotation_df,
    main = "All DEGs with Cluster Annotations"
  )
  dev.off()

  # Save cluster assignments
  row_clust <- data.frame(
    GeneID = names(clusters),
    Cluster = clusters
  )
  write.csv(row_clust, file = "gene_clusters.csv", row.names = FALSE, quote = TRUE)

  # Merge cluster info back to main results
  df2 <- merge(df2, row_clust, by.x = "Geneid", by.y = "GeneID", all.x = TRUE)
  write.csv(df2, file = paste0("ARFD_DE_results_LFC", lfc_threshold, "_p",
                                gsub("\\.", "", as.character(padj_threshold)), "_clustered.csv"),
            row.names = FALSE, quote = TRUE)

  cat("\nGenes per cluster:\n")
  print(table(row_clust$Cluster))
}
```

### Auxin-Responsive Genes Heatmap (GUS_aux DEGs)

```{r heatmap_auxin_responsive, fig.width=10, fig.height=6}
# Filter for genes differentially expressed in GUS_aux vs GUS
df_auxin_responsive <- df2 %>%
  filter(`Up_Down-GUS_aux` %in% c("UP", "Down"))

if (nrow(df_auxin_responsive) > 0) {
  cat("Auxin-responsive genes (GUS_aux DEGs):", nrow(df_auxin_responsive), "\n")

  df_heat_aux <- df_auxin_responsive %>%
    dplyr::select(all_of(counts_cols)) %>%
    as.matrix()
  rownames(df_heat_aux) <- df_auxin_responsive$Geneid

  svglite("Auxin_Responsive_heatmap.svg", width = 10, height = 6)
  pheatmap(
    df_heat_aux,
    scale = "row",
    show_rownames = FALSE,
    show_colnames = TRUE,
    cluster_cols = FALSE,
    cluster_rows = TRUE,
    main = "Auxin-Responsive Genes Heatmap"
  )
  dev.off()
}
```

## Volcano Plots

```{r volcano_plots, fig.width=10, fig.height=6}
library(ggrepel)

# Create volcano plot for each treatment
for (con in treatment_constructs) {
  l2fc_col <- paste0("log2FoldChange-", con)
  padj_col <- paste0("padj-", con)
  up_down_col <- paste0("Up_Down-", con)

  # Prepare plot data
  plot_data <- df2 %>%
    filter(!is.na(.data[[padj_col]]) & !is.na(.data[[l2fc_col]])) %>%
    mutate(
      neg_log10_padj = -log10(.data[[padj_col]]),
      regulation = ifelse(.data[[up_down_col]] == "UP", "Upregulated",
                          ifelse(.data[[up_down_col]] == "Down", "Downregulated", "Not significant"))
    )

  p <- ggplot(plot_data, aes_string(x = paste0("`", l2fc_col, "`"),
                                     y = "neg_log10_padj",
                                     col = "regulation")) +
    geom_vline(xintercept = c(-lfc_threshold, lfc_threshold), col = 'gray', linetype = 'dashed') +
    geom_hline(yintercept = -log10(padj_threshold), col = 'gray', linetype = 'dashed') +
    geom_point(size = 1, alpha = 0.7) +
    scale_color_manual(values = c('Downregulated' = '#639FC4',
                                  'Not significant' = 'gray',
                                  'Upregulated' = '#FFB300')) +
    labs(color = con,
         x = expression('log'[2]*'FC'),
         y = expression('-log'[10]*'adjusted p-value'),
         title = paste("Volcano Plot:", con, "vs", control_construct)) +
    theme_classic()

  print(p)

  svglite(paste0("Volcano_", con, ".svg"), width = 10, height = 6)
  print(p)
  dev.off()
}
```

## Expression Boxplots for Selected Genes

```{r boxplots_selected_genes, fig.width=12, fig.height=10}
# Define genes of interest (modify as needed)
# Example: top 10 most significantly DE genes across all constructs
genes_of_interest <- df2 %>%
  filter(if_any(all_of(ud_cols), ~ . %in% c("UP", "Down"))) %>%
  head(20) %>%
  pull(Geneid)

if (length(genes_of_interest) > 0) {
  # Get sample columns (excluding averages)
  sample_cols <- sample_metadata$sample_name

  # Reshape data for plotting
  df_long <- df2 %>%
    filter(Geneid %in% genes_of_interest) %>%
    dplyr::select(Geneid, all_of(sample_cols)) %>%
    pivot_longer(
      cols = all_of(sample_cols),
      names_to = "Sample",
      values_to = "Normalized_Reads"
    ) %>%
    mutate(
      Construct = gsub("-\\d+$", "", Sample),
      Construct = factor(Construct, levels = all_constructs)
    )

  ggplot(df_long, aes(x = Construct, y = Normalized_Reads)) +
    geom_boxplot() +
    facet_wrap(~ Geneid, scales = "free_y", ncol = 4) +
    theme_bw(base_size = 10) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(
      x = "Construct",
      y = "Normalized Reads",
      title = "Expression of Selected Genes Across Constructs"
    )
}
```

## UpSet Plots

```{r upset_plots, fig.width=10, fig.height=6}
library(UpSetR)

# Prepare gene sets for UP-regulated genes
up_genes_list <- list()
down_genes_list <- list()

for (con in treatment_constructs) {
  up_down_col <- paste0("Up_Down-", con)

  up_genes_list[[con]] <- df2 %>%
    filter(.data[[up_down_col]] == "UP") %>%
    pull(Geneid)

  down_genes_list[[con]] <- df2 %>%
    filter(.data[[up_down_col]] == "Down") %>%
    pull(Geneid)
}

# UP-regulated UpSet plot
if (any(sapply(up_genes_list, length) > 0)) {
  upset_matrix_up <- fromList(up_genes_list)

  svglite("UpSet_UP_regulated.svg", width = 10, height = 6)
  print(upset(
    upset_matrix_up,
    sets = treatment_constructs,
    keep.order = TRUE,
    order.by = "freq",
    mainbar.y.label = "UP-regulated gene intersections",
    sets.x.label = "Genes per construct"
  ))
  dev.off()

  upset(
    upset_matrix_up,
    sets = treatment_constructs,
    keep.order = TRUE,
    order.by = "freq",
    mainbar.y.label = "UP-regulated gene intersections",
    sets.x.label = "Genes per construct"
  )
}

# DOWN-regulated UpSet plot
if (any(sapply(down_genes_list, length) > 0)) {
  upset_matrix_down <- fromList(down_genes_list)

  svglite("UpSet_DOWN_regulated.svg", width = 10, height = 6)
  print(upset(
    upset_matrix_down,
    sets = treatment_constructs,
    keep.order = TRUE,
    order.by = "freq",
    mainbar.y.label = "DOWN-regulated gene intersections",
    sets.x.label = "Genes per construct"
  ))
  dev.off()

  upset(
    upset_matrix_down,
    sets = treatment_constructs,
    keep.order = TRUE,
    order.by = "freq",
    mainbar.y.label = "DOWN-regulated gene intersections",
    sets.x.label = "Genes per construct"
  )
}
```

## GO Term Enrichment Analysis

```{r go_enrichment, fig.width=12, fig.height=10}
library(clusterProfiler)
library(org.At.tair.db)

# Perform GO enrichment for each construct's UP-regulated genes
all_enrichment_results <- list()

for (con in treatment_constructs) {
  up_down_col <- paste0("Up_Down-", con)

  # Get UP-regulated genes
  up_genes <- df2 %>%
    filter(.data[[up_down_col]] == "UP") %>%
    pull(Geneid)

  if (length(up_genes) >= 5) {  # Need minimum genes for enrichment
    ego <- tryCatch({
      enrichGO(
        gene = up_genes,
        OrgDb = org.At.tair.db,
        keyType = "TAIR",
        ont = "BP",
        pAdjustMethod = "BH",
        pvalueCutoff = 0.05,
        qvalueCutoff = 0.05
      )
    }, error = function(e) {
      message(sprintf("No enrichment results for %s: %s", con, e$message))
      return(NULL)
    })

    if (!is.null(ego) && nrow(as.data.frame(ego)) > 0) {
      ego_df <- as.data.frame(ego) %>%
        arrange(p.adjust) %>%
        head(15)
      ego_df$Construct <- con
      all_enrichment_results[[con]] <- ego_df
    }
  }
}

# Combine and plot if results exist
if (length(all_enrichment_results) > 0) {
  combined_enrichment <- bind_rows(all_enrichment_results)
  combined_enrichment$Construct <- factor(combined_enrichment$Construct,
                                          levels = treatment_constructs)

  p_go <- ggplot(combined_enrichment, aes(
    x = Construct,
    y = Description,
    size = Count,
    color = -log10(p.adjust)
  )) +
    geom_point() +
    scale_color_gradientn(colours = c("#440F57", "#424285", "#2C748E", "#37B977", "#FFCB27")) +
    theme_bw() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      axis.text.y = element_text(size = 8)
    ) +
    labs(title = "GO Term Enrichment (UP-regulated genes)")

  print(p_go)

  ggsave("GO_enrichment_UP.svg", plot = p_go, width = 12, height = 10)
}
```

## Inverse Correlation Analysis

```{r inverse_correlation}
# Find genes inversely correlated with a reference gene
# Modify reference_gene as needed

reference_gene <- "AT1G15050"  # Example: modify to your gene of interest

# Get sample columns
sample_cols <- sample_metadata$sample_name

# Create expression matrix for DEGs
df_DEGs_expr <- df2 %>%
  filter(if_any(all_of(ud_cols), ~ . %in% c("UP", "Down"))) %>%
  dplyr::select(Geneid, all_of(sample_cols))

if (reference_gene %in% df_DEGs_expr$Geneid) {
  expr_mat <- df_DEGs_expr %>%
    column_to_rownames("Geneid") %>%
    as.matrix()

  ref_expr <- as.numeric(expr_mat[reference_gene, ])

  # Calculate correlations
  gene_cor <- apply(expr_mat, 1, function(x) {
    cor(x, ref_expr, use = "pairwise.complete.obs", method = "pearson")
  })

  # Calculate p-values
  p_vals <- apply(expr_mat, 1, function(x) {
    test_result <- cor.test(x, ref_expr, use = "pairwise.complete.obs", method = "pearson")
    test_result$p.value
  })

  # Adjust p-values
  p_adj <- p.adjust(p_vals, method = "BH")

  # Combine results
  cor_results <- data.frame(
    Geneid = rownames(expr_mat),
    correlation = gene_cor,
    p_value = p_vals,
    p_adj = p_adj
  )

  # Filter for inversely correlated genes
  inversely_correlated <- cor_results %>%
    filter(correlation < -0.5 & p_adj < 0.05)

  cat("\nGenes inversely correlated with", reference_gene, ":\n")
  cat("Number of inversely correlated genes:", nrow(inversely_correlated), "\n")

  if (nrow(inversely_correlated) > 0) {
    write.csv(inversely_correlated,
              file = paste0(reference_gene, "_inverse_correlations.csv"),
              row.names = FALSE, quote = TRUE)
  }
}
```

## Comparison with Published Data (Taylor et al.)

This section compares your results with the published protoplast data from Taylor et al.

```{r compare_datasets, fig.width=12, fig.height=10}
# Load the published dataset
# Place the file "ARFD_Up_Down_Regulated_LFC-1_p01_sorted.csv" in your working directory
published_file <- "ARFD_Up_Down_Regulated_LFC-2_p01_sorted.csv"

if (file.exists(published_file)) {

  published_df <- read.csv(published_file, check.names = FALSE)

  cat("=== Dataset Comparison ===\n\n")

  # Map construct names between datasets
  # Published: GUSaux_A, 5D_A, 6D_A, 7D_A, 8D_A, 19D_A
  # Your data: GUS_aux, 5D, 6D, 7D, 8D, 19D
  construct_map <- data.frame(
    published = c("GUSaux_A", "5D_A", "6D_A", "7D_A", "8D_A", "19D_A"),
    current = c("GUS_aux", "5D", "6D", "7D", "8D", "19D")
  )

  # Summary comparison table
  comparison_summary <- data.frame(
    Construct = construct_map$current,
    Published_UP = NA,
    Published_Down = NA,
    Current_UP = NA,
    Current_Down = NA
  )

  for (i in 1:nrow(construct_map)) {
    pub_con <- construct_map$published[i]
    cur_con <- construct_map$current[i]

    pub_col <- paste0("Up_Down-", pub_con)
    cur_col <- paste0("Up_Down-", cur_con)

    if (pub_col %in% colnames(published_df)) {
      comparison_summary$Published_UP[i] <- sum(published_df[[pub_col]] == "UP", na.rm = TRUE)
      comparison_summary$Published_Down[i] <- sum(published_df[[pub_col]] == "Down", na.rm = TRUE)
    }

    if (cur_col %in% colnames(df2)) {
      comparison_summary$Current_UP[i] <- sum(df2[[cur_col]] == "UP", na.rm = TRUE)
      comparison_summary$Current_Down[i] <- sum(df2[[cur_col]] == "Down", na.rm = TRUE)
    }
  }

  print(comparison_summary)

  # Calculate overlap for each construct
  cat("\n=== Gene Overlap Analysis ===\n\n")

  overlap_results <- list()

  for (i in 1:nrow(construct_map)) {
    pub_con <- construct_map$published[i]
    cur_con <- construct_map$current[i]

    pub_col <- paste0("Up_Down-", pub_con)
    cur_col <- paste0("Up_Down-", cur_con)

    if (pub_col %in% colnames(published_df) && cur_col %in% colnames(df2)) {

      # UP-regulated genes
      pub_up <- published_df$Geneid[published_df[[pub_col]] == "UP"]
      cur_up <- df2$Geneid[df2[[cur_col]] == "UP"]

      # Down-regulated genes
      pub_down <- published_df$Geneid[published_df[[pub_col]] == "Down"]
      cur_down <- df2$Geneid[df2[[cur_col]] == "Down"]

      # Calculate overlaps
      up_overlap <- length(intersect(pub_up, cur_up))
      down_overlap <- length(intersect(pub_down, cur_down))

      # Jaccard similarity
      up_jaccard <- up_overlap / length(union(pub_up, cur_up))
      down_jaccard <- if(length(union(pub_down, cur_down)) > 0) {
        down_overlap / length(union(pub_down, cur_down))
      } else { NA }

      overlap_results[[cur_con]] <- data.frame(
        Construct = cur_con,
        UP_Published = length(pub_up),
        UP_Current = length(cur_up),
        UP_Overlap = up_overlap,
        UP_Jaccard = round(up_jaccard, 3),
        Down_Published = length(pub_down),
        Down_Current = length(cur_down),
        Down_Overlap = down_overlap,
        Down_Jaccard = round(down_jaccard, 3)
      )

      cat(sprintf("\n%s:\n", cur_con))
      cat(sprintf("  UP: %d published, %d current, %d overlap (Jaccard: %.2f)\n",
                  length(pub_up), length(cur_up), up_overlap, up_jaccard))
      cat(sprintf("  Down: %d published, %d current, %d overlap (Jaccard: %.2f)\n",
                  length(pub_down), length(cur_down), down_overlap,
                  ifelse(is.na(down_jaccard), 0, down_jaccard)))
    }
  }

  overlap_df <- bind_rows(overlap_results)
  write.csv(overlap_df, "dataset_overlap_comparison.csv", row.names = FALSE)

  # Visualize overlap with Venn diagrams for key constructs
  library(ggVennDiagram)

  # Create Venn diagrams for each construct
  venn_plots <- list()

  for (i in 1:nrow(construct_map)) {
    pub_con <- construct_map$published[i]
    cur_con <- construct_map$current[i]

    pub_col <- paste0("Up_Down-", pub_con)
    cur_col <- paste0("Up_Down-", cur_con)

    if (pub_col %in% colnames(published_df) && cur_col %in% colnames(df2)) {

      pub_up <- published_df$Geneid[published_df[[pub_col]] == "UP"]
      cur_up <- df2$Geneid[df2[[cur_col]] == "UP"]

      if (length(pub_up) > 0 && length(cur_up) > 0) {
        venn_list <- list(
          Published = pub_up,
          Current = cur_up
        )

        p <- ggVennDiagram(venn_list, label_alpha = 0) +
          scale_fill_gradient(low = "white", high = "#3498db") +
          labs(title = paste(cur_con, "- UP-regulated genes")) +
          theme(legend.position = "none")

        venn_plots[[cur_con]] <- p
      }
    }
  }

  # Display Venn diagrams in a grid
  if (length(venn_plots) > 0) {
    library(patchwork)
    combined_venn <- wrap_plots(venn_plots, ncol = 3)
    print(combined_venn)
    ggsave("venn_comparison_UP.svg", combined_venn, width = 12, height = 8)
  }

  # Correlation of fold changes between datasets
  cat("\n=== Fold Change Correlation ===\n\n")

  fc_correlations <- data.frame(
    Construct = character(),
    Pearson_r = numeric(),
    Spearman_rho = numeric(),
    N_genes = integer()
  )

  for (i in 1:nrow(construct_map)) {
    pub_con <- construct_map$published[i]
    cur_con <- construct_map$current[i]

    pub_lfc <- paste0("log2FoldChange-", pub_con)
    cur_lfc <- paste0("log2FoldChange-", cur_con)

    if (pub_lfc %in% colnames(published_df) && cur_lfc %in% colnames(df2)) {

      # Merge on gene ID
      merged <- merge(
        published_df[, c("Geneid", pub_lfc)],
        df2[, c("Geneid", cur_lfc)],
        by = "Geneid"
      )

      # Remove NAs
      merged <- merged[complete.cases(merged), ]

      if (nrow(merged) > 10) {
        pearson_r <- cor(merged[[pub_lfc]], merged[[cur_lfc]], method = "pearson")
        spearman_rho <- cor(merged[[pub_lfc]], merged[[cur_lfc]], method = "spearman")

        fc_correlations <- rbind(fc_correlations, data.frame(
          Construct = cur_con,
          Pearson_r = round(pearson_r, 3),
          Spearman_rho = round(spearman_rho, 3),
          N_genes = nrow(merged)
        ))

        cat(sprintf("%s: Pearson r = %.3f, Spearman rho = %.3f (n = %d genes)\n",
                    cur_con, pearson_r, spearman_rho, nrow(merged)))
      }
    }
  }

  print(fc_correlations)
  write.csv(fc_correlations, "fold_change_correlations.csv", row.names = FALSE)

  # Scatter plot of fold changes for ARF6 (the most active)
  pub_lfc_6d <- "log2FoldChange-6D_A"
  cur_lfc_6d <- "log2FoldChange-6D"

  if (pub_lfc_6d %in% colnames(published_df) && cur_lfc_6d %in% colnames(df2)) {
    merged_6d <- merge(
      published_df[, c("Geneid", pub_lfc_6d)],
      df2[, c("Geneid", cur_lfc_6d)],
      by = "Geneid"
    )
    merged_6d <- merged_6d[complete.cases(merged_6d), ]

    p_scatter <- ggplot(merged_6d, aes_string(x = paste0("`", pub_lfc_6d, "`"),
                                               y = paste0("`", cur_lfc_6d, "`"))) +
      geom_point(alpha = 0.3, size = 1) +
      geom_abline(slope = 1, intercept = 0, color = "red", linetype = "dashed") +
      geom_smooth(method = "lm", color = "blue", se = TRUE) +
      theme_bw() +
      labs(
        title = "ARF6Î”: Published vs Current Log2 Fold Changes",
        x = "Published Log2FC (Protoplasts)",
        y = "Current Log2FC (Your Data)"
      ) +
      coord_fixed()

    print(p_scatter)
    ggsave("fold_change_scatter_6D.svg", p_scatter, width = 8, height = 8)
  }

} else {
  cat("Published data file not found. Please add 'ARFD_Up_Down_Regulated_LFC-1_p01_sorted.csv' to your working directory.\n")
}
```

## Specific Gene Family Comparisons

Compare expression of key auxin-responsive gene families between datasets.

```{r gene_family_comparison, fig.width=14, fig.height=10}
if (exists("published_df")) {

  # Define gene families of interest
  aux_iaa_genes <- c("AT4G14560", "AT1G04240", "AT1G04250", "AT2G22670", "AT1G15580",
                     "AT1G52830", "AT3G23030", "AT2G33310", "AT1G04100", "AT1G04550",
                     "AT4G28640", "AT1G80390", "AT2G46990", "AT4G14550", "AT1G51950",
                     "AT3G04730", "AT1G04240", "AT3G16500", "AT3G62100", "AT2G01200",
                     "AT4G29080", "AT1G19220", "AT4G32280", "AT3G17600", "AT1G15050",
                     "AT3G15540", "AT5G43700", "AT1G73590", "AT2G33310")

  tmo_genes <- c("AT1G68510", "AT5G57420", "AT5G60200", "AT2G36010")  # TMO3, TMO5, TMO6, TMO7

  lbd_genes <- c("AT2G42430", "AT2G45420", "AT2G40470", "AT1G31320",  # LBD16, LBD17, LBD18, LBD4
                 "AT5G66870", "AT3G02550", "AT4G00220", "AT2G42440")

  # Function to compare a gene family
  compare_gene_family <- function(genes, family_name, pub_df, cur_df) {

    results <- data.frame()

    for (i in 1:nrow(construct_map)) {
      pub_con <- construct_map$published[i]
      cur_con <- construct_map$current[i]

      pub_lfc <- paste0("log2FoldChange-", pub_con)
      cur_lfc <- paste0("log2FoldChange-", cur_con)
      pub_ud <- paste0("Up_Down-", pub_con)
      cur_ud <- paste0("Up_Down-", cur_con)

      for (gene in genes) {
        pub_row <- pub_df[pub_df$Geneid == gene, ]
        cur_row <- cur_df[cur_df$Geneid == gene, ]

        if (nrow(pub_row) > 0 && nrow(cur_row) > 0) {
          results <- rbind(results, data.frame(
            Gene = gene,
            Construct = cur_con,
            Published_LFC = ifelse(pub_lfc %in% colnames(pub_row), pub_row[[pub_lfc]], NA),
            Current_LFC = ifelse(cur_lfc %in% colnames(cur_row), cur_row[[cur_lfc]], NA),
            Published_UpDown = ifelse(pub_ud %in% colnames(pub_row), pub_row[[pub_ud]], ""),
            Current_UpDown = ifelse(cur_ud %in% colnames(cur_row), cur_row[[cur_ud]], "")
          ))
        }
      }
    }

    return(results)
  }

  # Compare TMO genes (TARGET OF MONOPTEROS)
  tmo_comparison <- compare_gene_family(tmo_genes, "TMO", published_df, df2)

  if (nrow(tmo_comparison) > 0) {
    cat("\n=== TMO Gene Comparison ===\n")

    tmo_wide <- tmo_comparison %>%
      filter(!is.na(Published_LFC) & !is.na(Current_LFC)) %>%
      mutate(
        LFC_Diff = Current_LFC - Published_LFC,
        Same_Direction = sign(Published_LFC) == sign(Current_LFC)
      )

    print(tmo_wide %>% dplyr::select(Gene, Construct, Published_LFC, Current_LFC, LFC_Diff))

    # Heatmap of TMO genes
    tmo_heat_pub <- tmo_comparison %>%
      filter(!is.na(Published_LFC)) %>%
      dplyr::select(Gene, Construct, Published_LFC) %>%
      pivot_wider(names_from = Construct, values_from = Published_LFC) %>%
      column_to_rownames("Gene")

    tmo_heat_cur <- tmo_comparison %>%
      filter(!is.na(Current_LFC)) %>%
      dplyr::select(Gene, Construct, Current_LFC) %>%
      pivot_wider(names_from = Construct, values_from = Current_LFC) %>%
      column_to_rownames("Gene")

    if (nrow(tmo_heat_pub) > 1 && nrow(tmo_heat_cur) > 1) {
      par(mfrow = c(1, 2))
      pheatmap(as.matrix(tmo_heat_pub), main = "TMO Genes - Published",
               cluster_rows = FALSE, cluster_cols = FALSE)
      pheatmap(as.matrix(tmo_heat_cur), main = "TMO Genes - Current",
               cluster_rows = FALSE, cluster_cols = FALSE)
    }
  }

  # Compare LBD genes
  lbd_comparison <- compare_gene_family(lbd_genes, "LBD", published_df, df2)

  if (nrow(lbd_comparison) > 0) {
    cat("\n=== LBD Gene Comparison ===\n")

    lbd_wide <- lbd_comparison %>%
      filter(!is.na(Published_LFC) & !is.na(Current_LFC))

    print(lbd_wide %>% dplyr::select(Gene, Construct, Published_LFC, Current_LFC))
  }

  write.csv(tmo_comparison, "TMO_gene_comparison.csv", row.names = FALSE)
  write.csv(lbd_comparison, "LBD_gene_comparison.csv", row.names = FALSE)
}
```

## Session Info

```{r session_info}
sessionInfo()
```
